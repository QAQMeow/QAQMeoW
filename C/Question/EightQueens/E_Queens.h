#include<stdio.h>
#define Queens 8
typedef struct Chessboard
{
	int Row;  //行
	int Column;  //列
	// Row Column 用来记录本节点初始设为1的位置
	int board[Queens][Queens];
	int snum;
	struct Chessboard* parent; // 父节点
	struct Chessboard* Son; //最后一个子节点
	struct Chessboard* brother; //前一个兄弟
}Chessboard;

typedef struct Chessboard* Cb;

//初始化
Cb InitTree();

//增加子节点
void AddSon(Cb C);

//初步建立树
void CreatTree(Cb C);

//根据条件输出
int PrintTree(Cb C);

/*
八皇后问题：

问题描述: 自行搜索 八皇后

本程序解决思路：

建立一个8+1层 树
根节点 数组全为0
在父节点的基础上添加子节点，从每列第一个元素开始，下列是上列的子节点 不添加条件的情况下 共8 × 8 × 8 + 1 个节点 
将父节点数组赋值给子节点并将子节点中数组，对相应数组位置赋值 1，每个节点只在父节点数组的基础上赋值一次

以4 × 4数组为例：
根节点
0 0 0 0  
0 0 0 0 
0 0 0 0
0 0 0 0

第一层
子节点 1（在父节点的基础上对第 1 行第 1 列赋值1）   子节点 2（在父节点的基础上对第 1 行第 2 列赋值1） 子节点 ...
1 0 0 0  																			0 1 0 0 
0 0 0 0  																			0 0 0 0
0 0 0 0	 																			0 0 0 0
0 0 0 0  																			0 0 0 0

第二层
子节点 1-1（在父节点的基础上对第 2 行第 1 列赋值1）   子节点 1-2（在父节点的基础上对第 1 行第 2 列赋值1）节点1-...  子节点 2-1（在父节点的基础上对第 2 行第 1 列赋值1）:   节点 1-2（在父节点的基础上对第 2 行第 2 列赋值1）节点2-... ... ...节点4-...   
1 0 0 0  																		1 0 0 0 								0 1 0 0                            	                0 1 0 0 
1 0 0 0  																		0 1 0 0                 				1 0 0 0 											0 1 0 0
0 0 0 0	 																		0 0 0 0                 				0 0 0 0 											0 0 0 0
0 0 0 0 																		0 0 0 0  								0 0 0 0												0 0 0 0

共1+4层 共 4 × 4 × 4 + 1个节点，每个数组每行至多只有一个赋值为1

赋值时可添加条件初步筛选
根据条件 若子节点 中Column == 父节点Column 或者==父节点Column +1或者 == 父节点Column-1 则赋值为 0，否则对相应位置赋值为1
仍以4 × 4数组为例：

.
.
.
不添加条件时：
第二层
子节点 1-1（在父节点的基础上对第 2 行第 1 列赋值1）   ...
1 0 0 0  																		                         	 
1 0 0 0  																					
0 0 0 0	 																
0 0 0 0

根据条件赋值：（父节点中 Row Column 用来记录本节点数组为1的位置，此时子节点的Column与父节点相同，数组相应位置设为0）
第二层
子节点 1-1（在父节点的基础上对第 2 行第 1 列赋值0）   ...
1 0 0 0  																		                         	 
0 0 0 0  																					
0 0 0 0	 																
0 0 0 0

//
初步筛选后
根据条件输出
/*输出条件
1.数组元素总和 == Queens
2.每列元素和 == 1
3. 两条斜对角线和 ==2
*/